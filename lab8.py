# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jpD8GlBe9_Jnl0cBUhjj3RNOwsQd1LuF
"""

#task1

N,K=map(int, input().split())
root=list(range(N + 1))
len=[1]*(N + 1)
def friend(x):
    while root[x]!=x:
        root[x]=root[root[x]]
        x=root[x]
    return x
def friendship(x,y):
    root1=friend(x)
    root2=friend(y)
    if root1== root2:
        return len[root1]
    if len[root1]<len[ root2]:
        root1,root2=root2,root1
    root[root2]=root1
    len[root1]+=len[ root2]
    return len[root1]
all=[]
for i in range(K):
    a,b=map(int,input().split())
    sum=friendship(a,b)
    all.append(str(sum))
print('\n'.join(all))

#task_2
N,M=map(int, input().split())
connections=[]
for i in range(M):
    x,y,z=map(int, input().split())
    connections.append((z,x,y))
connections.sort()
root=list(range(N + 1))
def find(x):
    while root[x]!=x:
        root[x]=root[root[x]]
        x=root[x]
    return x
cost = 0
for z,x,y in connections:
    root1=find(x)
    root2=find(y)
    if root1!=root2:
        root[root2]=root1
        cost+=z
print(cost)

#task_3
def find(ancestor, node):
    if ancestor[node] != node:
        ancestor[node] = find(ancestor, ancestor[node])
    return ancestor[node]

def union(ancestor, depth, node1, node2):
    root1 = find(ancestor, node1)
    root2 = find(ancestor, node2)

    if root1 == root2:
        return

    if depth[root1] < depth[root2]:
        ancestor[root1] = root2
    elif depth[root1] > depth[root2]:
        ancestor[root2] = root1
    else:
        ancestor[root2] = root1
        depth[root1] += 1

def mst_kruskal(vertex_count, edge_list):
    edge_list.sort(key=lambda edge: edge[2])

    ancestor = list(range(vertex_count + 1))
    depth = [0] * (vertex_count + 1)

    mst_edges = []
    total_cost = 0

    for from_node, to_node, cost in edge_list:
        if find(ancestor, from_node) != find(ancestor, to_node):
            union(ancestor, depth, from_node, to_node)
            mst_edges.append((from_node, to_node, cost))
            total_cost += cost

    return mst_edges, total_cost

def main():
    vertex_count, edge_count = map(int, input().split())

    edge_list = []
    for _ in range(edge_count):
        node_u, node_v, weight = map(int, input().split())
        edge_list.append((node_u, node_v, weight))

    mst_edges, mst_cost = mst_kruskal(vertex_count, edge_list)

    if len(mst_edges) < vertex_count - 1:
        print(-1)
        return

    mst_edge_set = set()
    for u, v, _ in mst_edges:
        mst_edge_set.add((min(u, v), max(u, v)))

    second_best = float('inf')

    for i, edge in enumerate(mst_edges):
        u, v, w = edge

        partial_mst = mst_edges[:i] + mst_edges[i+1:]

        smallest_addition = float('inf')

        ancestor = list(range(vertex_count + 1))
        depth = [0] * (vertex_count + 1)

        for a, b, _ in partial_mst:
            union(ancestor, depth, a, b)

        for a, b, cost in edge_list:
            if (min(a, b), max(a, b)) == (min(u, v), max(u, v)):
                continue

            if (min(a, b), max(a, b)) in mst_edge_set:
                continue

            if find(ancestor, a) != find(ancestor, b):
                new_cost = mst_cost - w + cost
                if mst_cost < new_cost < smallest_addition:
                    smallest_addition = new_cost

        if smallest_addition < float('inf'):
            second_best = min(second_best, smallest_addition)

    print(second_best if second_best < float('inf') else -1)

if _name_ == "_main_":
    main()