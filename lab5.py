# -*- coding: utf-8 -*-
"""Lab5

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1em-gSvwICJGOuB-DB0L4itPhOOzOevY2
"""

#task1
n, m = map(int, input().split())
adj = [[] for _ in range(n + 1)]
for _ in range(m):
    u, v = map(int, input().split())
    adj[u].append(v)
    adj[v].append(u)
for i in range(1, n + 1):
    adj[i].sort()
v = [False] * (n + 1)
q= [1]
v[1] = True
res= []

while q:
    u = q.pop(0)
    res.append(str(u))
    for visited in adj[u]:
        if not v[visited]:
            v[visited] = True
            q.append(v)
print(' '.join(res))

#task2
n, m = map(int, input().split())
u = list(map(int, input().split()))
v = list(map(int, input().split()))
adj = [[] for _ in range(n + 1)]
for i in range(m):
    x = u[i]
    y = v[i]
    adj[x].append(y)
    adj[y].append(x)

elem_stack = [1]
v = [False] * (n + 1)
res = []

while elem_stack:
    elem = elem_stack.pop()
    if not v[elem]:
        v[elem] = True
        res.append(str(elem))
        for i in sorted(adj[elem], reverse=True):
            elem_stack.append(i)

print(' '.join(res) + ' ')


# 6 8
# 1 5 3 4 6 1 6 4
# 5 3 4 6 2 3 3 1

#taskC
n, m, s, d = map(int, input().split())
u = list(map(int, input().split()))
v = list(map(int, input().split()))
adj = [[] for _ in range(n + 1)]
for i in range(m):
    x = u[i]
    y = v[i]
    adj[x].append(y)
    adj[y].append(x)
for i in range(n + 1):
    adj[i].sort()
if s == d:
    print(0)
    print(s)
else:
    dis= [-1] * (n + 1)
    p = [-1] * (n + 1)
    dis[s] = 0
    q = [[s]]
    while q:
        current = q.pop(0)
        next = set()
        for node in current:
            for n in adj[node]:
                if dis[n] == -1:
                    dis[n] = dis[node] + 1
                    p[n] = node
                    next.add(n)
                elif dis[n] == dis[node] + 1:
                    if p[n] > node:
                        p[n] = node

        if next:
            q.append(sorted(next))

    if dis[d] == -1:
        print(-1)
    else:
        road = []
        current = d
        while current != s:
            road.append(current)
            current = p[current]
        road.append(s)
        road.reverse()
        print(dis[d])
        print(' '.join(map(str,  road)))
# 5 10 5 3
# 2 1 5 3 1 4 2 4 1 4
# 5 5 4 5 2 2 3 1 3 3

#task4
def bfs(initial, adj, x):
    root = [-1] * (x + 1)
    dis = [-1] * (x + 1)
    q = [initial]
    dis[initial] = 0
    p = 0
    while p < len(q):
        a = q[p]
        p += 1
        for i in adj[a]:
            if dis[i] == -1:
                dis[i] = dis[a] + 1
                root[i] = a
                q.append(i)
    return dis, root
def road(start, end, parent):
    path = []
    current = end
    while current != -1:
        path.append(current)
        if current == start:
            break
        current = parent[current]
    if current == -1:
        return []
    return path[::-1]
n, m, s, d, k = map(int, input().split())
adj_1 = [[] for _ in range(n + 1)]
for _ in range(m):
    x, y = map(int, input().split())
    adj_1[x].append(y)
if s == d == k:
    print(0)
    print(s)
else:
    dis1, s_p = bfs(s, adj_1, n)
    if dis1[k] == -1:
        print(-1)
    else:
        dis2, k_p= bfs(k, adj_1, n)
        if dis2[d] == -1:
            print(-1)
        else:
            p1 = road(s, k, s_p)
            p2 = road(k, d, k_p)[1:]
            com = p1 + p2
            print(len(com) - 1)
            print(' '.join(map(str, com)))


# 5 1
# 1 2
# 1 4
# 5 2
# 4 5
# 3 2

#taskE

n, m = map(int, input().split())
adj = [[] for _ in range(n + 1)]
for _ in range(m):
    x, y = map(int, input().split())
    adj[x].append(y)
v = [0] * (n + 1)
def dfs(st):
    stack = [st]
    while stack:
        node = stack[-1]
        if v[node] == 0:
            v[node] = 1
        com = True
        cycle = False
        for j in adj[node]:
            if v[j] == 0:
                stack.append(j)
                com = False
                break
            elif v[j] == 1:
                return True
        if com:
            v[node] = 2
            stack.pop()
    return False

for i in range(1, n + 1):
    if v[i] == 0:
        if dfs(i):
            print("YES")
            break
else:
    print("NO")


# 6 5
# 6 4
# 6 3
# 4 5
# 6 2
# 4 1
# ----

#taskF
r, h = map(int, input().split())
graph = [input().strip() for row in range(r)]
v = [[False] * h for row in range(r)]
dia_count = 0
arrow = [(-1, 0), (1, 0), (0, -1), (0, 1)]
for row in range(r):
    for col in range(h):
        if not v[row][col] and graph[row][col] != '#':
            q = [(row, col)]
            v[row][col] = True
            c_dia = 0
            if graph[row][col] == 'D':
                c_dia += 1
            while q:
                x, y = q.pop(0)
                for i, j in arrow:
                    a, b = x + i, y + j
                    if 0 <= a < r and 0 <= b < h:
                        if not v[a][b] and graph[a][b] != '#':
                            v[a][b] = True
                            if graph[a][b] == 'D':
                                c_dia += 1
                            q.append((a, b))
            dia_count = max(dia_count, c_dia)
print(dia_count)

