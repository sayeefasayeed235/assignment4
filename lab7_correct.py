# -*- coding: utf-8 -*-
"""Lab7_Correct

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KJPDquQyKHmx4xDiM2d0DyQnZzgl7HLs
"""

#tasA
import heapq
N,M,S,D=map(int, input().split())
u=list(map(int, input().split()))
v=list(map(int, input().split()))
w=list(map(int, input().split()))
adj = [[] for i in range(N + 1)]
for i in range(M):
    x=u[i]
    y=v[i]
    wei=w[i]
    adj[x].append((y,wei))
infinity=float('inf')
dis=[infinity]*(N + 1)
o=[None]*(N + 1)
dis[S] = 0
heap=[]
heapq.heappush(heap,(0,S))
while heap:
    dis_c,u= heapq.heappop(heap)
    if u== D:
        break
    if dis_c>dis[u]:
        continue
    for i,j in adj[u]:
        if dis[i] >dis_c+j:
            dis[i] =dis_c+j
            o[i]=u
            heapq.heappush(heap,(dis[i],i))
if dis[D]==infinity:
    print(-1)
else:
    print(dis[D])
    p=[]
    x=D
    while x is not None:
        p.append(x)
        x=o[x]
    p.reverse()
    print(' '.join(map(str,p)))

# InputCopy
# 4 3 4 2
# 1 3 4
# 2 2 3
# 3 4 5
# OutputCopy
# 9
# 4 3 2

#TaskB
import heapq
N,M,S,T=map(int, input().split())
def alice_bob(i,adj,n):
    infinity=float('inf')
    dis=[infinity]*(n + 1)
    dis[i] = 0
    heap=[(0,i)]
    heapq.heapify(heap)
    while heap:
        v,u= heapq.heappop(heap)
        if v>dis[u]:
            continue
        for i,j in adj[u]:
            if dis[i]>v+j:
                dis[i]=v+j
                heapq.heappush(heap,(dis[i],i))
    return dis
if S==T:
    print(0, S)
    exit()
adj=[[] for i in range(N + 1)]
for p in range(M):
    x,y,z= map(int,input().split())
    adj[x].append((y,z))
alice=alice_bob(S,adj,N)
bob=alice_bob(T,adj,N)
min=float('inf')
r=-1
for i in range(1,N + 1):
    x=alice[i]
    y=bob[i]
    if x==float('inf') or y==float('inf'):
        continue
    max_time= max(x,y)
    if max_time<min:
        min=max_time
        r=i
    elif max_time==min:
        if i<r:
            r=i
if r==-1:
    print(-1)
else:
    print(min,r)

#TaskC
import heapq
n,m=map(int, input().split())
adj=[[] for i in range(n + 1)]
for i in range(m):
    x,y,z=map(int,input().split())
    adj[x].append((y,z))
    adj[y].append((x,z))
infinity=float('inf')
dist=[infinity]*(n + 1)
dist[1]=0
heap=[]
heapq.heappush(heap, (0, 1))
while heap:
    current,u=heapq.heappop(heap)
    if current>dist[u]:
        continue
    for i,j in adj[u]:
        new=max(current,j)
        if new<dist[i]:
            dist[i]=new
            heapq.heappush(heap,(new,i))
res=[]
for i in range(1,n + 1):
    if i == 1:
        res.append(0)
    else:
        res.append(dist[i] if dist[i] !=infinity else -1)
print(' '.join(map(str, res)))

#TaskD
import heapq
n,m,S,D=map(int,input().split())
w=list(map(int,input().split()))
adj=[[] for i in range(n + 1)]
for i in range(m):
    x,y=map(int,input().split())
    adj[x].append((y,w[y-1]))
infinity=float('inf')
dis=[infinity]*(n + 1)
dis[S]=w[S-1]
heap=[(dis[S],S)]
heapq.heapify(heap)
while heap:
    current,u=heapq.heappop(heap)
    if u == D:
        break
    if current>dis[u]:
        continue
    for i,j in adj[u]:
        if dis[i]>current+j:
            dis[i]=current+j
            heapq.heappush(heap,(dis[i],i))

if dis[D]!=infinity:
    print(dis[D])
else:
    print(-1)

#TaskE
import heapq
n,m=map(int, input().split())
x=list(map(int, input().split()))
y=list(map(int, input().split()))
z=list(map(int, input().split()))
adj = [[] for _ in range(n + 1)]
for i in range(m):
    adj[x[i]].append((y[i],z[i]))
infinity=float('inf')
dis=[[infinity]*2 for i in range(n + 1)]
heap=[]
for i in adj[1]:
    x,y=i
    z=y% 2
    if dis[x][z]>y:
        dis[x][z] =y
        heapq.heappush(heap, (y,x,z))
while heap:
    current,node,last_z = heapq.heappop(heap)
    if node==n:
        continue
    if current>dis[node][last_z]:
        continue
    for i,j in adj[node]:
        new_z = j% 2
        if new_z == last_z:
            continue
        new_dist=current+j
        if new_dist < dis[i][new_z]:
            dis[i][new_z]=new_dist
            heapq.heappush(heap,(new_dist,i,new_z))
min_dis=min(dis[n][0],dis[n][1])
if min_dis!=infinity:
    print(min_dis)
else:
    print(-1)

