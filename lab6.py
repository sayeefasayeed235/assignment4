# -*- coding: utf-8 -*-
"""lab6

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12DRk607-YAEQjdiaxOvFfUs0VBCpUi_k
"""

#taskA
n, m = map(int, input().split())
adj_list=[[] for _ in range(n + 1)]
incoming=[0]*(n+1)
for _ in range(m):
    a, b = map(int,input().split())
    adj_list[a].append(b)
    incoming[b]+=1
q= []
for i in range(1, n + 1):
    if incoming[i]==0:
        q.append(i)
start=0
res=[]
while start<len(q):
    u=q[start]
    start+=1
    res.append(u)
    for nodes in adj_list[u]:
       incoming[nodes]-=1
       if incoming[nodes]==0:
            q.append(nodes)
if len(res)!= n:
    print(-1)
else:
    print(' '.join(map(str, res)))

# 4 6
# 1 2
# 1 3
# 4 1
# 2 3
# 2 4
# 4 3
# OutputCopy
# -1

#taskB
n,m=map(int,input().split())
adj_list=[[] for _ in range(n + 1)]
for _ in range(m):
    u,v=map(int,input().split())
    adj_list[u].append(v)
    adj_list[v].append(u)
status=[-1]*(n + 1)
bipart=True
total=0
for i in range(1, n + 1):
    if status[i]==-1:
        q=[i]
        status[i]=0
        count = [1, 0]
        con = True
        root = 0
        while root<len(q) and con:
            c=q[root]
            root+=1
            for i in adj_list[c]:
                if status[i]==-1:
                    status[i]=1-status[c]
                    count[status[i]]+=1
                    q.append(i)
                elif status[i]==status[c]:
                    con = False
                    bipart = False
                    break
            if not con:
                break
        if not con:
            break
        total += max(count)
if bipart:
    print(total)

#taskc
n=int(input())
x,y,x_1,y_1=map(int, input().split())
if x==x_1 and y==y_1:
    print(0)
else:
    x3=x_1
    y3=y_1
    size=n + 1
    v=[False]*(size * size)
    v[x*size + y]=True
    directions=[(2, 1), (2, -1), (-2, 1), (-2, -1),(1, 2), (1, -2), (-1, 2), (-1, -2)]
    l=[(x, y)]
    s=0
    status=False
    while l and not status:
        s += 1
        next=[]
        for a, b in l:
            for dx, dy in directions:
                new_a=a+dx
                new_b=b+dy
                if 1<=new_a<=n and 1<=new_b<= n:
                    m=new_a * size + new_b
                    if not v[m]:
                        if new_a ==x3 and new_b==y3:
                            print(s)
                            status= True
                            break
                        v[m] = True
                        next.append((new_a, new_b))
            if status:
                break
        l=next
    if not status:
        print(-1)

#taskD WRONGGG
n,m=map(int, input().split())
edge_list=[]
for i in range(n + 1):
    edge_list.append([])
for _ in range(n - 1):
    u, v = map(int, input().split())
    edge_list[u].append(v)
    edge_list[v].append(u)
c_list=[]
for i in range(n + 1):
    c_list.append([])
root=[0]*(n + 1)
root[m]=-1
q=[m]
s=0
while  s< len(q):
    u=q[s]
    s+=1
    for j in edge_list[u]:
        if j !=root[u]:
            if root[j]== 0:
                root[j]=u
                c_list[j].append(j)
                q.append(j)
size=[1]*(n + 1)
stack=[(m,False)]
while stack:
    node,a=stack.pop()
    if not a:
        stack.append((node,True))
        for k in reversed(c_list[node]):
            stack.append((k, False))
    else:
        for k in c_list[node]:
            size[node] += size[k]
q=int(input())
for _ in range(q):
    x = int(input())
    print(size[x])

#TaskE
n=int(input())
adj=[]
for i in range(n+1):
    adj.append([])
for i in range(n-1):
    x,y=map(int, input().split())
    adj[x].append(y)
    adj[y].append(x)
def bfs(root):
    p=0
    queue=[]
    v=[False]*(n + 1)
    queue.append((root,0))
    v[root]=True
    dis=0
    node=root
    while p<len(queue):
        a,b=queue[p]
        p+=1
        for i in adj[a]:
            if not v[i]:
                v[i] = True
                new =b+1
                if new>dis:
                    dis= new
                    node=i
                queue.append((i,new))
    return node,dis
x,z=bfs(1)
y,c=bfs(x)
print(c)
print(x,y)

# taskF
from heapq import heappush, heappop
n=int(input())
m=[input().strip() for i in range(n)]
for i in range(n - 1):
    a=m[i]
    b=m[i+1]
    size=min(len(a), len(b))
    diff=False
    for j in range(size):
        if a[j]!=b[j]:
            diff=True
            break
    if not diff and len(a) > len(b):
        print(-1)
        exit()
chars=set()
for w in m:
    for c in w:
        chars.add(c)
s=sorted(chars)
adj={c: [] for c in chars}
inner={c: 0 for c in chars}
for i in range(n - 1):
    a=m[i]
    b=m[i+1]
    size=min(len(a), len(b))
    for j in range(size):
        x=a[j]
        y=b[j]
        if x!=y:
            if y not in adj[x]:
                adj[x].append(y)
                inner[y]+=1
            break
heap=[]
final=[]
for c in s:
    if inner[c] == 0:
        heappush(heap, c)
while heap:
    u=heappop(heap)
    final.append(u)
    for v in adj[u]:
        inner[v]-=1
        if inner[v]==0:
            heappush(heap, v)
if len(final)!=len(chars):
    print(-1)
else:
    print(''.join(final))



